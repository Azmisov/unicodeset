/* UnicodeSet grammar: https://www.unicode.org/reports/tr35/tr35.html#Unicode_Sets
	Also for reference, but less precise: https://unicode-org.github.io/icu-docs/apidoc/dev/icu4j/com/ibm/icu/text/UnicodeSet.html
	EBNF syntax: https://www.w3.org/TR/2017/REC-xquery-31-20170321/#EBNFNotation
	Character code points
		#x26: &
		#x2B: +
		#x2D: -
		#x5C: \
		#x5E: ^
		#x7B: {
		#x7D: }
		#x7E: ~
		#x5B: [
		#x5D: ]
		#x3A: :
		#x20: space
		for whitespace, see https://stackoverflow.com/questions/4731055/whitespace-matching-regex-java

	prop: \p{propName=value} OR [:propName=value:]
	a set of characters: [abcdef]
	can include a range via hyphen: [abc0-9]
	can use {} to denote multicharacter grapheme strings: [{abc}0-9]
	can use whitespace for readability: [ { a b c } 0 - 9 ]
*/
root 			::= prop | seq
seq				::= s? '[' s? invertSeq? s? (seqSetOps | stringRange | charRange)* ']' s?
invertSeq		::= [#x2D#x5E]

/* I'm allowing whitespace in between */
charRange		::= char (s? rangeSep s? char)? s?
/* String ranges not specified in original EBNF, but I'm mimicking charRange grammar */
stringRange		::=	'{' (s? char_str)+ s? '}' (s? rangeSep s? '{' (s? char_str)+ s? '}')? s?
rangeSep		::=	'-'
/* Excluding characters that are overly restrictive in original spec */
char			::=	[^#x2D#x5D#x7B#x5C#x9#xA-#xD#x20#x85#xA0#x1680#x180E#x2000-#x200A#x2028#x2029#x202F#x205F#x3000] | #x5C quoted
char_str		::=	[^#x7D#x5C#x9#xA-#xD#x20#x85#xA0#x1680#x180E#x2000-#x200A#x2028#x2029#x202F#x205F#x3000] | #x5C quoted

seqSetOps		::= root (s? setOp? s? root)* s?
/* We'll allow extension for symmetric difference and + for union */
setOp			::= [#x2B#x26#x2D#x7E]

prop 			::= s? (#x5C propNegateP s? '{' s? propNegate? perlName+ ((propEqual | propNotEqual) s? perlValue+)? '}' | '[:' s? propNegate? posixName+ ((propEqual | propNotEqual) s? posixValue+)? ':]') s?
propNegateP		::= [pP]
propEqual		::= '='
propNotEqual	::=	'≠'
propNegate		::= '^'
/* Less restrictive on property name, since its going to get mapped to a known property name anyways */
perlName 		::= [^=≠#x5C#x7D] | #x5C quoted
perlValue 		::= [^#x5C#x7D] | #x5C quoted
posixName 		::= [^=≠#x5C#x3A] | #x5C quoted
posixValue		::= [^#x5C#x3A] | #x5C quoted

quoted			::= q1 | q2 | q3 | q4 | q5
q1				::=	'u' (hex hex hex hex | bracketedHex)
q2				::= 'x' (hex hex | bracketedHex)
q3				::= 'U00' ('0' hex hex hex hex hex | '10' hex hex hex hex)
/* https://www.unicode.org/Public/UCD/latest/ucd/NamesList.txt */
q4				::= 'N' s? '{' s? charName s? '}'
charName		::= [A-Za-z0-9] (s? [A-Za-z0-9_#x2D])*
/* All valid unicode; in the spec, "uxUN" is excluded from the set, but I can find no references to uxUN anywhere.
	Could be the non-spacing combining character sets, perhaps from similarity to Mn character class. It
	could maybe indiate "unassigned"
*/
q5				::= [#x0-#x10FFFF]
bracketedHex 	::= s? '{' s? hexCodePoint (s hexCodePoint)* s? '}'
hexCodePoint 	::= '10' hex hex hex hex | hex hex? hex? hex? hex?
hex				::=	[0-9A-Fa-f]

s 				::= [#x9#xA-#xD#x20#x85#xA0#x1680#x180E#x2000-#x200A#x2028#x2029#x202F#x205F#x3000]+

